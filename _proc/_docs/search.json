[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Read and clean the input xAPI dataset",
    "section": "",
    "text": "source\n\nfoo\n\n foo ()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "xapi_analysis",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "xapi_analysis",
    "section": "Install",
    "text": "Install\npip install xapi_analysis"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "xapi_analysis",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2"
  },
  {
    "objectID": "input.html",
    "href": "input.html",
    "title": "Read an input JSON statement",
    "section": "",
    "text": "The libraries used to import the data:\n\nimport json\nimport pandas\nfrom typing import Union, List\nfrom datetime import datetime\nfrom pathlib import Path\nfrom fastcore.test import *\n\nAs an example, in this package we provide two files, a csv containing a collection of about 1000 statements, as well as a json of a stetement and all its related metadata\n\ncsv_file = '../example_statements.csv'\njson_file = '../example_single_statement.json'\n\nLet’s start parsing the json file\n\n\nload_statement\n\n load_statement (json_file:str)\n\nLoad a json from file and store the information in a Python dictionary object. If the file does not exist, returns an empty dict and print an error message\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\njson_file\nstr\nFilename of the json containing the statement\n\n\nReturns\ndict\nA dictionary representing the statement structure\n\n\n\n\nmy_statement = load_statement(json_file)\n\n\n\n\npretty_print_statement\n\n pretty_print_statement (statement:dict, indent:int=4)\n\nDisplays the content of the statement in a human readable format\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstatement\ndict\n\nthe statement dict imported from JSON\n\n\nindent\nint\n4\nindentation used when printing\n\n\nReturns\nNone\n\n\n\n\n\n\nsample_json = json.loads('[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]')\npretty_print_statement(sample_json, indent=2)\n\n[\n  \"foo\",\n  {\n    \"bar\": [\n      \"baz\",\n      null,\n      1.0,\n      2\n    ]\n  }\n]\n\n\n\nExtract the metadata information\nThe following methods are used to extract the metadata fields we may be interested in\n\n\n\n\nget_value\n\n get_value (statement:dict, key:str)\n\nReturn the value associated to the specified key in the statement dictionary. If the key does not exist, returns None\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nkey\nstr\nThe key we are interested in\n\n\nReturns\ntyping.Union[str, dict, NoneType]\nThe value associated to the key in the statement\n\n\n\n\ntest_eq(get_value(my_statement, \"not_a_key\"), None)\ntest_eq(get_value(my_statement, \"stored\"), \"2022-09-30T13:34:35.959Z\")\n\n\n\n\nget_stored\n\n get_stored (statement:dict)\n\nExtract the date and time information of when the statement was stored in the database\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ndatetime\ndatetime object representing the time the statement was stored in the database\n\n\n\n\nmy_date = datetime.strptime(\"2022-09-30T13:34:35.959Z\", \"%Y-%m-%dT%H:%M:%S.%f%z\")\ntest_eq(get_stored(my_statement), my_date)\n\n\n\n\nget_active\n\n get_active (statement:dict)\n\nExtract the Active field from the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nbool\nBoolean representive whether active or not\n\n\n\n\ntest_eq(get_active(my_statement), True)\n\n\n\n\nget_client\n\n get_client (statement:dict)\n\nExtract the client field from the statement\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nID of the client\n\n\n\n\ntest_eq(get_client(my_statement), \"60ffcf8d448b2d059a63e3c4\")\n\n\n\n\nget_LRS\n\n get_LRS (statement:dict)\n\nExtract the Learning Record Store ID field from the statement\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nID of the Learning Record Store\n\n\n\n\ntest_eq(get_LRS(my_statement), \"60ffcf8d448b2d059a63e3c3\")\n\n\ndef get_completed_fw_queues(statement: dict, # Our xAPI statement imported from JSON\n                ) -> List: # List of completed forwarding queues in the statement\n    \"\"\"\n    Extract the List of completed forwarding queues in the statement\n    \"\"\"\n    return get_value(statement, \"completedForwardingQueue\")\n\n\ntest_eq(get_completed_fw_queues(my_statement), list())\n\n\ndef get_failed_fw_log(statement: dict, # Our xAPI statement imported from JSON\n                ) -> List: # List of failed forwarding log messages in the statement\n    \"\"\"\n    Extract the List of failed forwarding log messages in the statement\n    \"\"\"\n    return get_value(statement, \"failedForwardingLog\")\n\n\ntest_eq(get_failed_fw_log(my_statement), list())\n\n\ndef get_completed_queues(statement: dict, # Our xAPI statement imported from JSON\n                ) -> List: # List of completed queues in the statement\n    \"\"\"\n    Extract the List of completed queues in the statement\n    \"\"\"\n    return get_value(statement, \"completedQueues\")\n\n\nCOMPL_QS = [\"STATEMENT_FORWARDING_QUEUE\", \"STATEMENT_PERSON_QUEUE\", \"STATEMENT_QUERYBUILDERCACHE_QUEUE\"]\ntest_eq(get_completed_queues(my_statement), COMPL_QS)"
  },
  {
    "objectID": "input_json.html",
    "href": "input_json.html",
    "title": "Read an input JSON statement",
    "section": "",
    "text": "The libraries used to import the data:\n\nimport json\nfrom typing import Union, List\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom fastcore.test import *\n\nAs an example, in this package we provide a json file containing a statement and all its related metadata\n\njson_file = '../example_single_statement.json'\n\n\nLoad an xAPI statement\nLet’s start parsing the json file\n\nsource\n\n\nload_statement\n\n load_statement (json_file:str)\n\nLoad a json from file and store the information in a Python dictionary object. If the file does not exist, returns an empty dict and print an error message\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\njson_file\nstr\nFilename of the json containing the statement\n\n\nReturns\ndict\nA dictionary representing the statement structure\n\n\n\n\nmy_statement = load_statement(json_file)\n\n\nsource\n\n\npretty_print_statement\n\n pretty_print_statement (statement:dict, indent:int=4)\n\nDisplays the content of the statement in a human readable format\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstatement\ndict\n\nthe statement dict imported from JSON\n\n\nindent\nint\n4\nindentation used when printing\n\n\nReturns\nNone\n\n\n\n\n\n\nsample_json = json.loads('[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]')\npretty_print_statement(sample_json, indent=2)\n\n[\n  \"foo\",\n  {\n    \"bar\": [\n      \"baz\",\n      null,\n      1.0,\n      2\n    ]\n  }\n]\n\n\n\nsource\n\n\nget_value\n\n get_value (statement:dict, key:str)\n\nReturn the value associated to the specified key in the statement dictionary. If the key does not exist, returns None\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nkey\nstr\nThe key we are interested in\n\n\nReturns\ntyping.Union[str, dict, typing.List, NoneType]\nThe value associated to the key in the statement\n\n\n\n\ntest_eq(get_value(my_statement, \"not_a_key\"), None)\ntest_eq(get_value(my_statement, \"stored\"), \"2022-09-30T13:34:35.959Z\")\n\n\nExtract statement data\nThe following methids are used to extract the actor, verb and object information, which represents the core information provided in each statement, as well as the version statement\n\nsource\n\n\n\nget_actor\n\n get_actor (statement:dict)\n\nExtract the actor information from the statement\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ndict\ndictionary containing actor information\n\n\n\n\ntest_actor = {\n      \"objectType\": \"Agent\",\n      \"name\": \"1s1116\",\n      \"mbox\": \"mailto:student@app.com\"\n    }\nactor = get_actor(my_statement)\ntest_eq(actor[\"objectType\"], test_actor[\"objectType\"])\ntest_eq(actor[\"name\"], test_actor[\"name\"])\ntest_eq(actor[\"mbox\"], test_actor[\"mbox\"])\n\n\nsource\n\n\nget_actor_name\n\n get_actor_name (statement:dict)\n\nQuick access to the name field of the actor, as it is the most relevant information\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nname of the actor\n\n\n\n\ntest_eq(get_actor_name(my_statement), \"1s1116\")\n\n\nsource\n\n\nget_verb\n\n get_verb (statement:dict)\n\nExtract the verb information from the statement\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ndict\ndictionary containing verb information\n\n\n\n\ntest_verb = {\n      \"id\": \"http://id.tincanapi.com/verb/selected/\",\n      \"display\": {\n        \"en-US\": \"Selected\"\n      }\n}\nverb = get_verb(my_statement)\ntest_eq(verb[\"id\"], test_verb[\"id\"])\ntest_eq(verb[\"display\"][\"en-US\"], test_verb[\"display\"][\"en-US\"])\n\n\nsource\n\n\nget_verb_str\n\n get_verb_str (statement:dict)\n\nQuick access to the display field of the verb, as it is the most relevant information\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nthe displayed verb\n\n\n\n\ntest_eq(get_verb_str(my_statement), \"Selected\")\n\n\nsource\n\n\nget_object\n\n get_object (statement:dict)\n\nExtract the object information from the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ndict\ndictionary containing object information\n\n\n\n\ntest_obj = {\n      \"objectType\": \"Activity\",\n      \"id\": \"http://example.com/activities/student-lesson\",\n      \"definition\": {\n        \"name\": {\n          \"en-US\": \"Lesson\"\n        },\n        \"description\": {\n          \"en-US\": \"Level 1 Module8 started\"\n        }\n      }\n}\nobj = get_object(my_statement)\ntest_eq(obj[\"id\"], test_obj[\"id\"])\ntest_eq(obj[\"objectType\"], test_obj[\"objectType\"])\ntest_eq(obj[\"definition\"][\"name\"][\"en-US\"], test_obj[\"definition\"][\"name\"][\"en-US\"])\ntest_eq(obj[\"definition\"][\"description\"][\"en-US\"], test_obj[\"definition\"][\"description\"][\"en-US\"])\n\n\nsource\n\n\nget_object_definition\n\n get_object_definition (statement:dict)\n\nQuick access to the object definition\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nthe object definition\n\n\n\n\ntest_eq(get_object_definition(my_statement), \"Lesson\")\n\n\nsource\n\n\nget_object_description\n\n get_object_description (statement:dict)\n\nQuick access to the object description\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nthe object description\n\n\n\n\ntest_eq(get_object_description(my_statement), \"Level 1 Module8 started\")\n\n\nExtract the metadata information\nThe following methods are used to extract the metadata fields we may be interested in\n\nGet general metadata information\n\nsource\n\n\n\n\nget_stored\n\n get_stored (statement:dict)\n\nExtract the date and time information of when the statement was stored in the database\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ndatetime\ndatetime object representing the time the statement was stored in the database\n\n\n\n\nmy_date = datetime.strptime(\"2022-09-30T13:34:35.959Z\", \"%Y-%m-%dT%H:%M:%S.%f%z\")\ntest_eq(get_stored(my_statement), my_date)\n\n\nsource\n\n\nget_timestamp\n\n get_timestamp (statement:dict)\n\nExtract the date and time information of when the statement was created\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ndatetime\ndatetime object representing the time the statement was generated\n\n\n\n\nmy_ts = datetime.strptime(\"2022-09-30T13:34:35.959Z\", \"%Y-%m-%dT%H:%M:%S.%f%z\")\ntest_eq(get_timestamp(my_statement), my_date)\n\n\nsource\n\n\nget_time_diff\n\n get_time_diff (statement:dict)\n\nCompute the time difference between when a statement was sent and when it was stored in the database\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ntimedelta\nTime difference between when the statement was sent and when it was stored\n\n\n\n\ntest_eq(get_time_diff(my_statement), timedelta()) # In our example statement the timestamps are the same\n\n\nGet Boolean metadata information\nThese methods return the metadata providing boolean information related to the statement\n\nsource\n\n\n\nis_active\n\n is_active (statement:dict)\n\nExtract the Active field from the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nbool\nBoolean representive whether active or not\n\n\n\n\ntest_eq(is_active(my_statement), True)\n\n\nsource\n\n\nis_voided\n\n is_voided (statement:dict)\n\nExtract the Active field from the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nbool\nBoolean representive whether statement is voided or not\n\n\n\n\ntest_eq(is_voided(my_statement), False)\n\n\nsource\n\n\nhas_generated_id\n\n has_generated_id (statement:dict)\n\nExtract the Active field from the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nbool\nBoolean representive whether statement has generated id\n\n\n\n\ntest_eq(has_generated_id(my_statement), False)\n\n\nGet ID metadata information\nThese methods return the metadata providing ID information\n\nsource\n\n\n\nget_client\n\n get_client (statement:dict)\n\nExtract the client field from the statement\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nID of the client\n\n\n\n\ntest_eq(get_client(my_statement), \"60ffcf8d448b2d059a63e3c4\")\n\n\nsource\n\n\nget_LRS\n\n get_LRS (statement:dict)\n\nExtract the Learning Record Store ID field from the statement\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nID of the Learning Record Store\n\n\n\n\ntest_eq(get_LRS(my_statement), \"60ffcf8d448b2d059a63e3c3\")\n\n\nsource\n\n\nget_id\n\n get_id (statement:dict)\n\nExtract the ID field from the statement\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nID of the statement\n\n\n\n\ntest_eq(get_id(my_statement), \"6336f06c6ce79d05ebef40a7\")\n\n\nsource\n\n\nget_persona_id\n\n get_persona_id (statement:dict)\n\nExtract the persona identifier\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nid of the persona associated to the statement\n\n\n\n\ntest_eq(get_persona_id(my_statement), \"6103e17eaed02c30c695bffb\")\n\n\nsource\n\n\nget_organisation\n\n get_organisation (statement:dict)\n\nExtract the persona identifier\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nid of the organization to the statement\n\n\n\n\ntest_eq(get_organisation(my_statement), \"60faab70448b2d059a63e375\")\n\n\nsource\n\n\nget_hash\n\n get_hash (statement:dict)\n\nExtract the hash\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nhash of the statement\n\n\n\n\ntest_eq(get_hash(my_statement), \"3268dd76c35a6077796979e0613654ecf449c46e\")\n\n\nGet queues metadata information\nThese methods return the metadata related to the queues information in the statement\n\nsource\n\n\n\nget_completed_fw_queues\n\n get_completed_fw_queues (statement:dict)\n\nExtract the List of completed forwarding queues in the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ntyping.List\nList of completed forwarding queues in the statement\n\n\n\n\ntest_eq(get_completed_fw_queues(my_statement), list())\n\n\nsource\n\n\nget_failed_fw_log\n\n get_failed_fw_log (statement:dict)\n\nExtract the List of failed forwarding log messages in the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ntyping.List\nList of failed forwarding log messages in the statement\n\n\n\n\ntest_eq(get_failed_fw_log(my_statement), list())\n\n\nsource\n\n\nget_completed_queues\n\n get_completed_queues (statement:dict)\n\nExtract the List of completed queues in the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ntyping.List\nList of completed queues in the statement\n\n\n\n\nCOMPL_QS = [\"STATEMENT_FORWARDING_QUEUE\", \"STATEMENT_PERSON_QUEUE\", \"STATEMENT_QUERYBUILDERCACHE_QUEUE\"]\ntest_eq(get_completed_queues(my_statement), COMPL_QS)\n\n\nsource\n\n\nget_completed_queues\n\n get_completed_queues (statement:dict)\n\nExtract the List of completed queues in the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ntyping.List\nList of completed queues in the statement\n\n\n\n\ntest_eq(get_completed_fw_queues(my_statement), list())\n\n\nsource\n\n\nget_dead_forwarding_queues\n\n get_dead_forwarding_queues (statement:dict)\n\nExtract the List of dead forwarding queues in the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ntyping.List\nList of dead forwarding queues in the statement\n\n\n\n\ntest_eq(get_dead_forwarding_queues(my_statement), list())\n\n\nsource\n\n\nget_pending_forwarding_queues\n\n get_pending_forwarding_queues (statement:dict)\n\nExtract the List of pending forwarding queues in the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ntyping.List\nList of completed queues in the statement\n\n\n\n\ntest_eq(get_pending_forwarding_queues(my_statement), list())\n\n\nsource\n\n\nget_processing_queues\n\n get_processing_queues (statement:dict)\n\nExtract the List of processing queues in the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ntyping.List\nList of processing queues in the statement\n\n\n\n\ntest_eq(get_processing_queues(my_statement), list())\n\n\nsource\n\n\nget_registrations\n\n get_registrations (statement:dict)\n\nExtract the List of registrations in the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ntyping.List\nList of registrations in the statement\n\n\n\n\ntest_eq(get_registrations(my_statement), list())"
  },
  {
    "objectID": "input_csv.html",
    "href": "input_csv.html",
    "title": "Read xAPI statements stored in a csv file",
    "section": "",
    "text": "The libraries used to import the data:\n\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nfrom typing import Set, List\nfrom datetime import datetime\nfrom fastcore.test import *\n\nAs an example, in this package we provide a csv file containing around 1000 xAPI statements.\n\ncsv_file = '../example_statements.csv'\n\n\nLoad statements from file\nLet’s start by reading the csv file\n\nstatements = pd.read_csv(csv_file, index_col=0, delimiter=',').reset_index(drop=True)\nstatements.head()\n\n\n\n\n\n  \n    \n      \n      timestamp\n      stored\n      actor\n      verb\n      object\n      result\n    \n  \n  \n    \n      0\n      2023-03-10 11:45:09.638000+00:00\n      2023-03-10T11:45:09.638Z\n      Teacher\n      Logged In\n      Salesianos\n      NaN\n    \n    \n      1\n      2023-03-10 11:52:00.020000+00:00\n      2023-03-10T11:52:00.020Z\n      PC006\n      Logged In\n      Salesianos\n      NaN\n    \n    \n      2\n      2023-03-10 11:52:04.063000+00:00\n      2023-03-10T11:52:04.063Z\n      PC008\n      Logged In\n      Salesianos\n      NaN\n    \n    \n      3\n      2023-03-10 11:52:05.177000+00:00\n      2023-03-10T11:52:05.177Z\n      Tablet1\n      Logged In\n      Salesianos\n      {\"score\":{\"raw\":0}}\n    \n    \n      4\n      2023-03-10 11:52:05.679000+00:00\n      2023-03-10T11:52:05.679Z\n      PC004\n      Logged In\n      Salesianos\n      NaN\n    \n  \n\n\n\n\nThe three most important columns are actor, verb and object, which create a sentence-like structure. We can see the actions that the app registers from the verb column.\n\n\n\nget_all_verbs\n\n get_all_verbs (df:pandas.core.frame.DataFrame)\n\nReturns a set with all verbs in the dataset\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndf\nDataFrame\nThe dataset containing the xAPI statements (one statement per row)\n\n\nReturns\ntyping.Set\nSet containing all the verbs occurring in the dataset\n\n\n\n\ntest_verbs = {'Logged In', 'Placed', 'Swiped', 'Asked', 'Started', 'Logged Out',\n       'Accepted', 'Set Turn', 'Suggested', 'Ran Out', 'Sent', 'Checked',\n       'Assigned', 'Canceled', 'Ended'}\ntest_eq(get_all_verbs(statements), test_verbs)\n\nWe provide similar functions for actors and objects\n\n\n\nget_all_actors\n\n get_all_actors (df:pandas.core.frame.DataFrame)\n\nReturns a set with all actors in the dataset\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndf\nDataFrame\nThe dataset containing the xAPI statements (one statement per row)\n\n\nReturns\ntyping.Set\nSet containing all the actors occurring in the dataset\n\n\n\n\ntest_actors = {'Teacher', 'PC006', 'PC008', 'Tablet1', 'PC004', 'PC009', 'PC007', 'PC003', 'Iphone 1',\n       'PC005', 'iPad2', 'Tablet 2', 'Android1', 'Android2', 'iPad1', 'PC002', 'Android4', 'Android3',\n       'iphone 1', 'iPhone 1', 'Ipad1', 'Tablet1 ', 'Ipad2'}\ntest_eq(get_all_actors(statements), test_actors)\n\n\n\n\nget_all_objects\n\n get_all_objects (df:pandas.core.frame.DataFrame)\n\nReturns a set with all objects in the dataset\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndf\nDataFrame\nThe dataset containing the xAPI statements (one statement per row)\n\n\nReturns\ntyping.Set\nSet containing all the objects occurring in the dataset\n\n\n\nThe list of unique objects is quite big, so we will not print it in this example.\nAs the actor values are usually associated to a user input (for example the username provided when starting the app), it makes sense to clean the values as to avoid that User1, user1 and user 1 are trated as the same user. The following functions allow to do just that, on the desired columns.\n\n\n\nremove_whitespaces\n\n remove_whitespaces (df:pandas.core.frame.DataFrame, cols:List)\n\nRemoves whitespaces from the specified columns in the dataframe.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndf\nDataFrame\nThe dataset containing the xAPI statements (one statement per row)\n\n\ncols\ntyping.List\nthe columns on which whitespaces should be removed\n\n\nReturns\nDataFrame\nThe dataframe after applying the function\n\n\n\n\n\n\nto_lowercase\n\n to_lowercase (df:pandas.core.frame.DataFrame, cols:List)\n\nConverts to lowercase the elements in the specified columns. The function only applies to columnns whose type is str\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndf\nDataFrame\nThe dataset containing the xAPI statements (one statement per row)\n\n\ncols\ntyping.List\nthe columns whose content should be made lowercase\n\n\nReturns\nDataFrame\nThe dataframe after applying the function\n\n\n\n\ntest_actors = {'teacher', 'pc006', 'pc008', 'tablet1', 'pc004', 'pc009', 'pc007', 'pc003', 'iphone1',\n               'pc005', 'ipad2', 'tablet2', 'android1', 'android2', 'ipad1', 'pc002', 'android4', 'android3'}\ndf = remove_whitespaces(statements, [\"actor\"])\ndf2 = to_lowercase(df, [\"actor\"])\ntest_eq(get_all_actors(df2), test_actors)\n\nWe may also be interested in removing specific rows from the dataset, for examples the ones associated to an actor that opted out of the intervention, or for verbs we do not care about. This could be the case for example for verbs like Log In or Log out, which provides information about when a user starts and stops the app, but may be not relevant in case our analysis is only about the interactions from within the app.\n\n\n\nremove_actors\n\n remove_actors (df:pandas.core.frame.DataFrame, cols:List)\n\nRemoves from the dataframe all the rows whose actor is in the specified list\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndf\nDataFrame\nThe dataset containing the xAPI statements (one statement per row)\n\n\ncols\ntyping.List\nthe list of actors to remove\n\n\nReturns\nDataFrame\nThe dataframe with the specified actors removed\n\n\n\n\nstatements = pd.read_csv(csv_file, index_col=0, delimiter=',').reset_index(drop=True)\ntest_actors = {'Teacher', 'PC006', 'PC008', 'Tablet1', 'PC004', 'PC009', 'PC007', 'PC003', 'Iphone 1',\n       'PC005', 'iPad2', 'Tablet 2', 'Android1', 'Android2'}\ntest_df = remove_actors(statements, ['iPad1', 'PC002', 'Android4', 'Android3',\n       'iphone 1', 'iPhone 1', 'Ipad1', 'Tablet1 ', 'Ipad2'])\ntest_eq(get_all_actors(test_df), test_actors)\n\n\n\n\nremove_verbs\n\n remove_verbs (df:pandas.core.frame.DataFrame, cols:List)\n\nRemoves from the dataframe all the rows whose actor is in the specified list\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndf\nDataFrame\nThe dataset containing the xAPI statements (one statement per row)\n\n\ncols\ntyping.List\nthe list of verbs to remove\n\n\nReturns\nDataFrame\nThe dataframe with the specified verbs removed\n\n\n\n\ntest_verbs = {'Placed', 'Swiped', 'Asked', 'Started', 'Accepted', 'Set Turn', 'Suggested', 'Ran Out',\n              'Sent', 'Checked', 'Assigned', 'Canceled', 'Ended'}\ntest_df = remove_verbs(statements, [\"Logged In\", \"Logged Out\"])\ntest_eq(get_all_verbs(test_df), test_verbs)\n\n\nxAPI statements analysys\nHere we present some functions that are typically applied when analysing xAPI statements data. For this, we will use a clean version of the statements dataset, where some of the functions described above has been applied\n\nstatements = remove_whitespaces(statements, [\"actor\"])\nstatements = to_lowercase(df, [\"actor\"])\nstatements = remove_verbs(statements, [\"Logged In\", \"Logged Out\"])\nstatements = remove_actors(statements, [\"android3\"])\nstatements.head(5)\n\n\n\n\n\n  \n    \n      \n      timestamp\n      stored\n      actor\n      verb\n      object\n      result\n    \n  \n  \n    \n      14\n      2023-03-10 11:52:18.277000+00:00\n      2023-03-10T11:52:18.277Z\n      iphone1\n      Placed\n      Earth\n      {\"score\":{\"raw\":0}}\n    \n    \n      15\n      2023-03-10 11:52:18.847000+00:00\n      2023-03-10T11:52:18.847Z\n      iphone1\n      Swiped\n      Left\n      {\"score\":{\"raw\":0}}\n    \n    \n      18\n      2023-03-10 11:52:29.001000+00:00\n      2023-03-10T11:52:29.001Z\n      iphone1\n      Placed\n      Earth\n      {\"score\":{\"raw\":0}}\n    \n    \n      19\n      2023-03-10 11:52:29.094000+00:00\n      2023-03-10T11:52:29.094Z\n      android2\n      Placed\n      Earth\n      {\"score\":{\"raw\":0}}\n    \n    \n      20\n      2023-03-10 11:52:29.194000+00:00\n      2023-03-10T11:52:29.194Z\n      iphone1\n      Swiped\n      Right\n      {\"score\":{\"raw\":0}}\n    \n  \n\n\n\n\nA typical check is to evaluate how many interactions are provided by each actor:\n\n\n\n\ncount_interactions\n\n count_interactions (df:pandas.core.frame.DataFrame)\n\nCreates a new dataframe counting the total number of statements associated to each actor\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndf\nDataFrame\nThe dataset containing the xAPI statements (one statement per row)\n\n\nReturns\nDataFrame\nA dataframe with the number of interactions of each actor\n\n\n\nOn our toy dataset, it looks like this:\n\ninteractions =  count_interactions(statements)\ninteractions\n\n\n\n\n\n  \n    \n      \n      actor\n      count\n    \n  \n  \n    \n      0\n      pc009\n      6\n    \n    \n      1\n      pc006\n      13\n    \n    \n      2\n      pc008\n      19\n    \n    \n      3\n      pc002\n      21\n    \n    \n      4\n      pc004\n      32\n    \n    \n      5\n      pc007\n      42\n    \n    \n      6\n      pc003\n      43\n    \n    \n      7\n      iphone1\n      86\n    \n    \n      8\n      ipad1\n      87\n    \n    \n      9\n      android4\n      106\n    \n    \n      10\n      teacher\n      112\n    \n    \n      11\n      android1\n      119\n    \n    \n      12\n      tablet1\n      133\n    \n    \n      13\n      ipad2\n      140\n    \n    \n      14\n      tablet2\n      145\n    \n    \n      15\n      android2\n      147\n    \n  \n\n\n\n\n\nsns.barplot(x='count', y='actor', data=interactions, palette='flare')\n\n<Axes: xlabel='count', ylabel='actor'>\n\n\n\n\n\nWe can also extract specific statements associated to just one actor and representing just one verb\n\n\n\nsubset_actor_verb\n\n subset_actor_verb (df:pandas.core.frame.DataFrame, actor:str, verb:str)\n\nReturns the subset of the original dataframe containing only statements with the specified actor and verb\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndf\nDataFrame\nThe dataset containing the xAPI statements (one statement per row)\n\n\nactor\nstr\nThe actor we are interested in\n\n\nverb\nstr\nThe verb we are interested in\n\n\nReturns\nDataFrame\nA dataframe containing only the statements with a specific actor and verb\n\n\n\n\ntmp = subset_actor_verb(statements, \"teacher\", \"Assigned\")\ntmp.head(5)\n\n\n\n\n\n  \n    \n      \n      timestamp\n      stored\n      actor\n      verb\n      object\n      result\n    \n  \n  \n    \n      316\n      2023-03-10 12:04:36.832000+00:00\n      2023-03-10T12:04:36.832Z\n      teacher\n      Assigned\n      7.72;iPhone_1\n      NaN\n    \n    \n      368\n      2023-03-10 12:05:37.368000+00:00\n      2023-03-10T12:05:37.368Z\n      teacher\n      Assigned\n      8.15;Android2\n      NaN\n    \n    \n      397\n      2023-03-10 12:06:24.752000+00:00\n      2023-03-10T12:06:24.752Z\n      teacher\n      Assigned\n      7.72;Tablet1\n      NaN\n    \n    \n      541\n      2023-03-10 12:11:20.420000+00:00\n      2023-03-10T12:11:20.420Z\n      teacher\n      Assigned\n      7.45;Tablet_2\n      NaN\n    \n    \n      582\n      2023-03-10 12:12:12.001000+00:00\n      2023-03-10T12:12:12.001Z\n      teacher\n      Assigned\n      7.72;iPad2\n      NaN\n    \n  \n\n\n\n\nFrom the subset we could analyse the objects to detect if there are any interesting patterns. In the example, we could extract the values (one is a score, the other the actor to whom it was assigned)\n\ndef split_column():\n    pass"
  }
]