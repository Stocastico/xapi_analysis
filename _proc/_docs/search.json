[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Read and clean the input xAPI dataset",
    "section": "",
    "text": "source\n\nfoo\n\n foo ()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "xapi_analysis",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "xapi_analysis",
    "section": "Install",
    "text": "Install\npip install xapi_analysis"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "xapi_analysis",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2"
  },
  {
    "objectID": "input.html",
    "href": "input.html",
    "title": "Read an input JSON statement",
    "section": "",
    "text": "The libraries used to import the data:\n\nimport json\nimport pandas\nfrom typing import Union, List\nfrom datetime import datetime\nfrom pathlib import Path\nfrom fastcore.test import *\n\nAs an example, in this package we provide two files, a csv containing a collection of about 1000 statements, as well as a json of a stetement and all its related metadata\n\ncsv_file = '../example_statements.csv'\njson_file = '../example_single_statement.json'\n\nLet’s start parsing the json file\n\n\nload_statement\n\n load_statement (json_file:str)\n\nLoad a json from file and store the information in a Python dictionary object. If the file does not exist, returns an empty dict and print an error message\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\njson_file\nstr\nFilename of the json containing the statement\n\n\nReturns\ndict\nA dictionary representing the statement structure\n\n\n\n\nmy_statement = load_statement(json_file)\n\n\n\n\npretty_print_statement\n\n pretty_print_statement (statement:dict, indent:int=4)\n\nDisplays the content of the statement in a human readable format\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstatement\ndict\n\nthe statement dict imported from JSON\n\n\nindent\nint\n4\nindentation used when printing\n\n\nReturns\nNone\n\n\n\n\n\n\nsample_json = json.loads('[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]')\npretty_print_statement(sample_json, indent=2)\n\n[\n  \"foo\",\n  {\n    \"bar\": [\n      \"baz\",\n      null,\n      1.0,\n      2\n    ]\n  }\n]\n\n\n\nExtract the metadata information\nThe following methods are used to extract the metadata fields we may be interested in\n\n\n\n\nget_value\n\n get_value (statement:dict, key:str)\n\nReturn the value associated to the specified key in the statement dictionary. If the key does not exist, returns None\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nkey\nstr\nThe key we are interested in\n\n\nReturns\ntyping.Union[str, dict, NoneType]\nThe value associated to the key in the statement\n\n\n\n\ntest_eq(get_value(my_statement, \"not_a_key\"), None)\ntest_eq(get_value(my_statement, \"stored\"), \"2022-09-30T13:34:35.959Z\")\n\n\n\n\nget_stored\n\n get_stored (statement:dict)\n\nExtract the date and time information of when the statement was stored in the database\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\ndatetime\ndatetime object representing the time the statement was stored in the database\n\n\n\n\nmy_date = datetime.strptime(\"2022-09-30T13:34:35.959Z\", \"%Y-%m-%dT%H:%M:%S.%f%z\")\ntest_eq(get_stored(my_statement), my_date)\n\n\n\n\nget_active\n\n get_active (statement:dict)\n\nExtract the Active field from the statement\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nbool\nBoolean representive whether active or not\n\n\n\n\ntest_eq(get_active(my_statement), True)\n\n\n\n\nget_client\n\n get_client (statement:dict)\n\nExtract the client field from the statement\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nID of the client\n\n\n\n\ntest_eq(get_client(my_statement), \"60ffcf8d448b2d059a63e3c4\")\n\n\n\n\nget_LRS\n\n get_LRS (statement:dict)\n\nExtract the Learning Record Store ID field from the statement\n\n\n\n\nType\nDetails\n\n\n\n\nstatement\ndict\nOur xAPI statement imported from JSON\n\n\nReturns\nstr\nID of the Learning Record Store\n\n\n\n\ntest_eq(get_LRS(my_statement), \"60ffcf8d448b2d059a63e3c3\")\n\n\ndef get_completed_fw_queues(statement: dict, # Our xAPI statement imported from JSON\n                ) -> List: # List of completed forwarding queues in the statement\n    \"\"\"\n    Extract the List of completed forwarding queues in the statement\n    \"\"\"\n    return get_value(statement, \"completedForwardingQueue\")\n\n\ntest_eq(get_completed_fw_queues(my_statement), list())\n\n\ndef get_failed_fw_log(statement: dict, # Our xAPI statement imported from JSON\n                ) -> List: # List of failed forwarding log messages in the statement\n    \"\"\"\n    Extract the List of failed forwarding log messages in the statement\n    \"\"\"\n    return get_value(statement, \"failedForwardingLog\")\n\n\ntest_eq(get_failed_fw_log(my_statement), list())\n\n\ndef get_completed_queues(statement: dict, # Our xAPI statement imported from JSON\n                ) -> List: # List of completed queues in the statement\n    \"\"\"\n    Extract the List of completed queues in the statement\n    \"\"\"\n    return get_value(statement, \"completedQueues\")\n\n\nCOMPL_QS = [\"STATEMENT_FORWARDING_QUEUE\", \"STATEMENT_PERSON_QUEUE\", \"STATEMENT_QUERYBUILDERCACHE_QUEUE\"]\ntest_eq(get_completed_queues(my_statement), COMPL_QS)"
  }
]